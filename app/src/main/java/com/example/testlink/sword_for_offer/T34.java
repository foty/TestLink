package com.example.testlink.sword_for_offer;

/**
 * Create by lxx
 * Date : 2020/8/7 9:16
 * Use by 从小到大的第n个丑数(丑数是只包含因子2,3,5的数，第一个丑数为1.)
 */
public class T34 {

    /**
     * 从题目可以得到阶梯的方向:目标丑数必定是由一个数x2或者x3或x5得到的。于是可以得到一个基本
     * 结构：循环n次，每次使用某个数x2，x3，x5，取最小的那个。假设每次相乘的数为A。题目关键就是
     * 求出这个A的值。最容易想到的:以前面的丑数(1,2,3,4,5,6..)分别乘以2,3,5:
     * 马上就会迎来新问题：如何在合适的时机使用正确的丑数乘以2,3,5。如果都以同一个数乘以2,3,5。必
     * 定会造成遗漏。比如2x2 = 4，2x3 = 6,2x5 = 10.这里就已经遗漏掉了很多丑数了。有个办法就是将
     * 每次产生的丑数保存起来，假设这个容器为C，每次去乘2,3,5的数也源自C。按照C里面的丑数顺序乘以
     * 2,3,5随后取最小的那个丑数(最接近前一个丑数)。那什么时候改变乘数呢?答案是当本次保存的丑数等于
     * 乘数时，改变乘数(即使用下一个丑数相乘)。因为当次保存的丑数是新产生的三个丑数中最小的一个，这个
     * 丑数都与乘数(另一个丑数)相等，再去使用下一个丑数相乘(改变乘数)，在容器C中是没有遗漏的。
     *
     *关键：何时改变乘数。
     * @param n
     * @return
     */
    public int solve(int n) {

        int[] arr = new int[n];
        arr[0] = 1;
        int a = 0, b = 0, c = 0;
        for (int i = 1; i < n; i++) {

            int min1 = arr[a] * 2;
            int min2 = arr[b] * 3;
            int min3 = arr[c] * 5;

            arr[i] = Math.min(Math.min(min1, min2), min3);

            // 主要还是通过 丑数可以拆分为几个小丑数 的性质 来得到的。
            // 这样每次取到最接近的丑数，对应的因子就 +1，就能保证取到所有的丑数（不会遗漏）
            if (arr[i] == min1) a++;
            if (arr[i] == min2) b++;
            if (arr[i] == min3) c++;

        }

        return arr[n - 1];
    }
}
