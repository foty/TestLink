package com.example.testlink.sword_for_offer;

/**
 * Create by lxx
 * Date : 2020/9/17 18:01
 * Use by 正则表达式匹配。
 * 描述:
 * 请实现一个函数用来匹配包含'. '和'*'的正则表达式。模式中的字符'.'表示任意一个字符，而'*'表示它前面的字符可
 * 以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串"aaa"与模式"a.a"和"ab*ac*a"匹配，
 * 但与"aa.a"和"ab*a"均不匹配。
 */
public class T52 {

    public boolean solve(String s, String p) {

        int a = s.length();
        int b = p.length();
        boolean[][] r = new boolean[a + 1][b + 1];

        // r[0][0] 俩个都是空串

        for (int i = 0; i <= s.length(); i++) {
            for (int j = 0; j <= p.length(); j++) {
                if (j == 0) {
                    r[i][j] = i == 0;
                } else {
                    if (p.charAt(j - 1) == '*') {
                        /**
                         * 看p串*前一位：
                         * 1.与s串不相等，*表示0次(s="a",p = "e*")。结果取决于p串前j-2位是否匹配(p串减去2位--e*)
                         * 即:r[i][j] = r[i][j-2]。
                         *
                         * 2-1.与s串相等，*表示0次(s="a",p="aa*")。结果取决于p串前j-2位是否匹配(与情况1相同):r[i][j] = r[i][j-2]
                         *
                         * 2-2.与s串相等，*表示1次(s="a",p="a*"/".*")。结果取决于p串前j-1位是否匹配(p串减掉*)
                         * 即:r[i][j] = r[i][j-1]
                         *
                         * 2-3与s串相等，*表示多次(s="aa",p="a*")。结果取决于s串前i-1位是否匹配(将a*看成一个整体，p串(a*)可以匹配多少个
                         * 取决于s串前i-1是否匹配，所以s串往前做减法)
                         * 即:r[i][j] = r[i-1][j]
                         *
                         * 第2点的三种情况随意一种为true即可。(一定是要使用||的)
                         */
                        // 1.细分情况
//                        if (s.charAt(i - 1) != p.charAt(j - 2) && '.' != p.charAt(j - 2)) {
//                            r[i][j] = r[i][j - 2];
//                        } else {
//                            //以下三种情况随意一种为true即可，所以使用 ||。
//                            r[i][j] = (r[i][j - 2] || r[i][j - 1] || r[i - 1][j]);
//                        }

                        /**
                         * 实际上，以上情况大体上可以分2种，匹配与不匹配。不匹配就不用说了，匹配1个与匹配n个的流程是一样的。所以又有:
                         *          | r[i][j-2](不匹配)
                         * r[i][j]= |
                         *          | r[i-1][j](匹配)
                         *
                         * 以上2种任意一种情况为true即可。
                         */
                        //2.大体情况 (做减法需要注意下标最小值为0)
                        if (i > 0 && j >= 2
                                && (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.')) {
                            r[i][j] = r[i - 1][j];
                        }
//                        r[i][j] = r[i][j] || r[i][j-2];
                        if (j >= 2)
                            r[i][j] |= r[i][j - 2];

                    } else {
                        // 为什么是i-1,j-1。因为在创建数组时给的容量是各自size +1。其中[0][0]位置
                        // 为双方为空串的情况。数组r[i]对应字符串/正则的位置就是 i-1。否则会导致越界。

                        if (i > 0 && (p.charAt(j - 1) == '.'
                                || p.charAt(j - 1) == s.charAt(i - 1))) { // 如果匹配，结果取决于前面的是否匹配
                            r[i][j] = r[i - 1][j - 1];
                        }
                    }
                }
            }
        }
        return r[a][b];
    }
}
