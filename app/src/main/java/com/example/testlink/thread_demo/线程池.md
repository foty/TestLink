使用线程池的好处:  
重用线程，减少新建-销毁线程的开销；  
有效控制线程并发数量，避免线程间抢占系统资源而导致阻塞；   
能够统一管理；

构造方法参数说明:  
* corePoolSize: 核心线程数量。核心线程默认情况下会一直存活在线程池中，除非设置了 allowCoreThreadTimeOut 为
true。默认下这个值是false。核心线程数线程数定义了最小可以同时运行的线程数量。

* maximumPoolSize: 线程池能容纳的最大线程总数。当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量
变为最大线程数。

* keepAliveTime: 线程存活超时时长，通常情况针对非核心线程。当线程池中的线程数量大于 corePoolSize 的时候，
如果这时没有新的任务提交，除核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 keepAliveTime 才会
被回收销毁。如果设置 allowCoreThreadTimeOut = true，则同样适用核心线程。

* unit: keepAliveTime 参数的时间单位。

* workQueue: 任务队列。当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，任务就会被
存放在队列中。

* threadFactory: 创建线程的工厂(ThreadFactory接口)，通常情况使用默认的即可
(Executors.defaultThreadFactory())

* handler: 饱和策略,共有4种。

代码分析:
```
 private static final int CORE_POOL_SIZE = 5;
 private static final int MAX_POOL_SIZE = 10;
 private static final int QUEUE_CAPACITY = 100;
 private static final Long KEEP_ALIVE_TIME = 1L;

 private final ThreadPoolExecutor executor;
 private List<Future<String>> futures;
 
 executor = new ThreadPoolExecutor(CORE_POOL_SIZE,MAX_POOL_SIZE,KEEP_ALIVE_TIME,TimeUnit.SECONDS,
 new ArrayBlockingQueue<Runnable>(QUEUE_CAPACITY),new ThreadPoolExecutor.CallerRunsPolicy());
```


遵循规则：   
判断当前正在工作的线程数量是否超过了核心线程，如果没有则直接创建核心线程执行任务。若执行成功则返回。   
判断线程池生命周期是否结束并且任务是否能成功添加到工作队列，再次检查此线程是否存活，并且任务能否移除队列，
如果可以，则将前一步添加的任务变更为拒绝执行。并且必要是需要重新开启一条线程。   
如果将任务使用非核心线程执行也失败，则拒绝此任务。