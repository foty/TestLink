使用线程池的好处:  
重用线程，减少新建-销毁线程的开销；  
有效控制线程并发数量，避免线程间抢占系统资源而导致阻塞；   
能够统一管理；

构造方法参数说明:  
* corePoolSize: 核心线程数量。核心线程默认情况下会一直存活在线程池中，除非设置了 allowCoreThreadTimeOut 为
true。默认下这个值是false。核心线程数线程数定义了最小可以同时运行的线程数量。

* maximumPoolSize: 线程池能容纳的最大线程总数。当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量
变为最大线程数。

* keepAliveTime: 线程存活超时时长，通常情况针对非核心线程。当线程池中的线程数量大于 corePoolSize 的时候，
如果这时没有新的任务提交，除核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 keepAliveTime 才会
被回收销毁。如果设置 allowCoreThreadTimeOut = true，则同样适用核心线程。

* unit: keepAliveTime 参数的时间单位。

* workQueue: 任务队列。当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，任务就会被
存放在队列中。

* threadFactory: 创建线程的工厂(ThreadFactory接口)，通常情况使用默认的即可
(Executors.defaultThreadFactory())

* handler: 饱和策略,共有4种。

线程池状态(生命周期):
* RUNNING：     此状态下线程池接受新任务并处理排队的任务;
* SHUTDOWN：    不接受新任务，但处理排队的任务;
* STOP：        不接受新任务，不处理排队的任务，且中断正在进行的任务;
* TIDYING：     所有任务已终止，workerCount为0，线程转换到状态整理，准备运行terminated()方法;
* TERMINATED：  terminated()运行完成;

代码分析:
```
 private static final int CORE_POOL_SIZE = 5;
 private static final int MAX_POOL_SIZE = 10;
 private static final int QUEUE_CAPACITY = 100;
 private static final Long KEEP_ALIVE_TIME = 1L;

 private final ThreadPoolExecutor executor;
 private List<Future<String>> futures;
 
 executor = new ThreadPoolExecutor(CORE_POOL_SIZE,MAX_POOL_SIZE,KEEP_ALIVE_TIME,TimeUnit.SECONDS,
 new ArrayBlockingQueue<Runnable>(QUEUE_CAPACITY),new ThreadPoolExecutor.CallerRunsPolicy());
 
 executor.execute(new Runnable() {
  @Override
            public void run() {
                System.out.println("=======");
            }
        });
```
execute方法内部: 
```
public void execute(Runnable command) {
        if (command == null)
            throw new NullPointerException();
        /*
         * Proceed in 3 steps:
         *
         * 1. If fewer than corePoolSize threads are running, try to
         * start a new thread with the given command as its first
         * task.  The call to addWorker atomically checks runState and
         * workerCount, and so prevents false alarms that would add
         * threads when it shouldn't, by returning false.
         *
         * 2. If a task can be successfully queued, then we still need
         * to double-check whether we should have added a thread
         * (because existing ones died since last checking) or that
         * the pool shut down since entry into this method. So we
         * recheck state and if necessary roll back the enqueuing if
         * stopped, or start a new thread if there are none.
         *
         * 3. If we cannot queue task, then we try to add a new
         * thread.  If it fails, we know we are shut down or saturated
         * and so reject the task.
         */
        int c = ctl.get();
        if (workerCountOf(c) < corePoolSize) {
            if (addWorker(command, true))
                return;
            c = ctl.get();
        }
        if (isRunning(c) && workQueue.offer(command)) {
            int recheck = ctl.get();
            if (! isRunning(recheck) && remove(command))
                reject(command);
            else if (workerCountOf(recheck) == 0)
                addWorker(null, false);
        }
        else if (!addWorker(command, false))
            reject(command);
    }
```
方法内部的英文注释里其实就是这块代码的解释了，三段解释刚好对应三个条件判断。这里翻译一下:   

* 如果运行的线程少于核心线程数量，则尝试用给定的命令作为第一个线程启动一个新线程任务。对addWorker的调用会自动检查
runState(运行状态)和workerCount(工作线程数量)，这样可以预防因不能增加线程时而产生的错误。此时返回false拒绝添加线程。

* 如果任务可以成功排队，那么我们仍然需要来再次检查我们是否应该添加一个线程(因为在上次检查后已有的已经死亡)或那样自从
进入此方法后池就关闭了。所以我们重新检查状态，必要时回滚队列停止，或启动一个新线程(如果没有线程)。   

* 如果我们不能将任务放入队列，那么我们尝试添加一个新的线程。如果它失败了，我们知道线程池被关闭或饱和了，因此拒绝这项任务。


具体了解:
第一个条件:如果 工作线程数<核心线程数   
看到``addWorker(command, true)``这个方法。如果此方法返回true，表示任务已经创建核心线程并执行。如果是false则不能添
加线程执行，而是要放入到队列中等待空闲线程执行(这是第二段的处理内容)。所以在这个方法要留意返回false的情况。进到这
个方法内部:      
方法开始先检查线程池状态，这里有第一个处返回false的情况。
```
  // Check if queue empty only if necessary.
  if (rs >= SHUTDOWN && 
        ! (rs == SHUTDOWN && 
         firstTask == null && 
         ! workQueue.isEmpty()))
      return false;
```
这个判断返回false的条件总结如下：
 * STOP、TIDYING、TERMINATED三种状态 ;
 * SHUTDOWN、STOP、TIDYING、TERMINATED四种状态，并且firstTask != null;
 * SHUTDOWN、STOP、TIDYING、TERMINATED四种状态，并且workQueue为空了;
 
继续往下是第二处返回false的情况：
```
   int wc = workerCountOf(c);
   if (wc >= CAPACITY ||
       wc >= (core ? corePoolSize : maximumPoolSize))
       return false;
```
这个也是比较好理解的: 
* 如果运行线程数等于或者超过了系统规定线程池上限(5亿多)；
* 创建核心线程但运行线程数量超过了核心线程容量；
* 创建非核心线程但运行线程数量超过了最大线程数量；

以上条件都不满足后，将会尝试将线程池的 workerCount数量+1。如果增加成功就跳出循环，准备添加线程执行任务了。如果增长失败
则先判断线程池状态是否发生改变，如果状态发生了改变则回到方法开始，循环走前面的步骤，否则循环重试增长workerCount。  

代码往下是增加线程执行任务的逻辑(以上条件没有不满足)。这里先将task包装成Worker对象(后面再对Worker介绍)，如果线程池有
状态为RUNNING或是SHUTDOWN且task为null时(状态为SHUTDOWN虽然不接受新任务，但是会处理队列中的任务)，则将work添加到存
放work的HashSet->workers中，同时更新线程池的最大容量largestPoolSize的值。以上操作都是通过重入锁(ReentrantLock，
内部封装了公平锁和非公平锁)来保证线程同步。如果work添加到workers成功，就执行它的start方法，最后返回true，addWorker()
结束。如果最后任务都未启动，线程池将执行回滚操作，将work从workers中移除，workerCount数量-1(对应前面的+1)。   

##### 关于Worker
Worker类继承AbstractQueuedSynchronizer类并实现Runnable接口,可以将自身作为任务在线程中执行。看到Worker的构造方法:
```
  Worker(Runnable firstTask) {
      setState(-1); // inhibit interrupts until runWorker
      this.firstTask = firstTask;
      this.thread = getThreadFactory().newThread(this);
  }
```
接收Runnable对象，将自身的这里的firstTask初始化，以自身创建的线程对象。Work对象调用start()方法后，会执行到自己的run
方法,实际就是调用自己的``runWorker()``方法,下面看这个runWorker方法：


从work中拿到任务task(Runnable),释放锁，如果task为空则通过 getTask()获取一个(其实就是从任务队列中获取)。
拿到任务后，加锁，防止被中断，

```
     final void runWorker(Worker w) {
        Thread wt = Thread.currentThread();
        Runnable task = w.firstTask;
        w.firstTask = null;
        w.unlock(); // allow interrupts
        boolean completedAbruptly = true;
        try {
            while (task != null || (task = getTask()) != null) {
                w.lock();
                // If pool is stopping, ensure thread is interrupted;
                // if not, ensure thread is not interrupted.  This
                // requires a recheck in second case to deal with
                // shutdownNow race while clearing interrupt
                if ((runStateAtLeast(ctl.get(), STOP) ||
                     (Thread.interrupted() &&
                      runStateAtLeast(ctl.get(), STOP))) &&
                    !wt.isInterrupted())
                    wt.interrupt();
                try {
                    beforeExecute(wt, task);
                    Throwable thrown = null;
                    try {
                        task.run();
                    } catch (RuntimeException x) {
                        thrown = x; throw x;
                    } catch (Error x) {
                        thrown = x; throw x;
                    } catch (Throwable x) {
                        thrown = x; throw new Error(x);
                    } finally {
                        afterExecute(task, thrown);
                    }
                } finally {
                    task = null;
                    w.completedTasks++;
                    w.unlock();
                }
            }
            completedAbruptly = false;
        } finally {
            processWorkerExit(w, completedAbruptly);
        }
    }
```
如果线程池状态为SHUTDOWN并且workQueue为空；
线程池状态为 STOP TIDYING TERMINATED;
boolean值time意思为是否超时回收(回收核心/非核心线程)，如果``allowCoreThreadTimeOut``为true，则超时回收线程，不
管是否超时(这点在前面的构造方法提到过)，否则就是线程池线程数量大于核心线程数量时回收线程。下面判断：

池子内线程数量大于了规定的线程池最大线程数量 + 需要回收线程并且超时获取任务对象
线程数量 > 1  + 任务队列为空


```
    private Runnable getTask() {
        boolean timedOut = false; // Did the last poll() time out?

        for (;;) {
            int c = ctl.get();
            int rs = runStateOf(c);

            // Check if queue empty only if necessary.
            if (rs >= SHUTDOWN && (rs >= STOP || workQueue.isEmpty())) {
                decrementWorkerCount();
                return null;
            }

            int wc = workerCountOf(c);

            // Are workers subject to culling?  
            boolean timed = allowCoreThreadTimeOut || wc > corePoolSize;

            if ((wc > maximumPoolSize || (timed && timedOut))
                && (wc > 1 || workQueue.isEmpty())) {
                if (compareAndDecrementWorkerCount(c))
                    return null;
                continue;
            }

            try {
                Runnable r = timed ?
                    workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :
                    workQueue.take();
                if (r != null)
                    return r;
                timedOut = true;
            } catch (InterruptedException retry) {
                timedOut = false;
            }
        }
    }
```

 
