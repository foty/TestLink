使用线程池的好处:  
重用线程，减少新建-销毁线程的开销；  
有效控制线程并发数量，避免线程间抢占系统资源而导致阻塞；   
能够统一管理；

构造方法参数说明:  
* corePoolSize: 核心线程数量。核心线程默认情况下会一直存活在线程池中，除非设置了 allowCoreThreadTimeOut 为
true。默认下这个值是false。核心线程数线程数定义了最小可以同时运行的线程数量。

* maximumPoolSize: 线程池能容纳的最大线程总数。当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量
变为最大线程数。

* keepAliveTime: 线程存活超时时长，通常情况针对非核心线程。当线程池中的线程数量大于 corePoolSize 的时候，
如果这时没有新的任务提交，除核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 keepAliveTime 才会
被回收销毁。如果设置 allowCoreThreadTimeOut = true，则同样适用核心线程。

* unit: keepAliveTime 参数的时间单位。

* workQueue: 任务队列。当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，任务就会被
存放在队列中。

* threadFactory: 创建线程的工厂(ThreadFactory接口)，通常情况使用默认的即可
(Executors.defaultThreadFactory())

* handler: 饱和策略,共有4种。

线程池状态(生命周期):
* RUNNING：     接受新任务并处理排队的任务;
* SHUTDOWN：    不接受新任务，但处理排队的任务;
* STOP：        不接受新任务，不处理排队的任务，且中断正在进行的任务;
* TIDYING：     所有任务已终止，workerCount为0，线程转换到状态整理，将运行terminated()钩子方法;
* TERMINATED：  terminated()完成;

代码分析:
```
 private static final int CORE_POOL_SIZE = 5;
 private static final int MAX_POOL_SIZE = 10;
 private static final int QUEUE_CAPACITY = 100;
 private static final Long KEEP_ALIVE_TIME = 1L;

 private final ThreadPoolExecutor executor;
 private List<Future<String>> futures;
 
 executor = new ThreadPoolExecutor(CORE_POOL_SIZE,MAX_POOL_SIZE,KEEP_ALIVE_TIME,TimeUnit.SECONDS,
 new ArrayBlockingQueue<Runnable>(QUEUE_CAPACITY),new ThreadPoolExecutor.CallerRunsPolicy());
 
 executor.execute(new Runnable() {
            @Override
            public void run() {
                System.out.println("=======");
            }
        });
```
execute方法内部: 
```
public void execute(Runnable command) {
        if (command == null)
            throw new NullPointerException();
        /*
         * Proceed in 3 steps:
         *
         * 1. If fewer than corePoolSize threads are running, try to
         * start a new thread with the given command as its first
         * task.  The call to addWorker atomically checks runState and
         * workerCount, and so prevents false alarms that would add
         * threads when it shouldn't, by returning false.
         *
         * 2. If a task can be successfully queued, then we still need
         * to double-check whether we should have added a thread
         * (because existing ones died since last checking) or that
         * the pool shut down since entry into this method. So we
         * recheck state and if necessary roll back the enqueuing if
         * stopped, or start a new thread if there are none.
         *
         * 3. If we cannot queue task, then we try to add a new
         * thread.  If it fails, we know we are shut down or saturated
         * and so reject the task.
         */
        int c = ctl.get();
        if (workerCountOf(c) < corePoolSize) {
            if (addWorker(command, true))
                return;
            c = ctl.get();
        }
        if (isRunning(c) && workQueue.offer(command)) {
            int recheck = ctl.get();
            if (! isRunning(recheck) && remove(command))
                reject(command);
            else if (workerCountOf(recheck) == 0)
                addWorker(null, false);
        }
        else if (!addWorker(command, false))
            reject(command);
    }
```
方法内部的英文注释里其实就是这块代码的解释了，三段解释刚好对应三个条件判断。这里翻译一下:   

* 如果运行的线程少于核心线程数量，则尝试用给定的命令作为第一个线程启动一个新线程任务。对addWorker的调用会自动检查runState(运行状态)和
workerCount(工作线程数量)，这样可以预防因不能增加线程时而产生的错误。此时返回false拒绝添加线程。  

* 如果任务可以成功排队，那么我们仍然需要来再次检查我们是否应该添加一个线程(因为在上次检查后已有的已经死亡)或那样自从进入此方法后池就关闭了。
所以我们重新检查状态，必要时回滚队列停止，或启动一个新线程，如果没有线程。   

* 如果我们不能将任务放入队列，那么我们尝试添加一个新的线程。如果它失败了，我们知道线程池被关闭或饱和了，因此拒绝这项任务。  

具体了解:
第一个条件:工作线程<核心线程。进到``addWorker(command, true)``这个方法内部：  
1. 检查线程池状态(线程池状态不为STOP、TIDYING、TERMINATED)