package com.example.testlink.data_structure.heap;

/**
 * Create by lxx
 * Date : 2021/2/24 16:21
 * Use by 堆。
 */
public class MyHeap {

    /**
     * 堆：
     * 1、概念 -> 堆的本质就是完全二叉树。(完全二叉树:从根结点到倒数第二层满足完美二叉树，最后一层可以不完全填充，其叶子结点都靠左对齐)。
     * 堆的逻辑结构是一颗完全二叉树，但物理结构是顺序表(一维数组)。
     *
     * 2、种类->2种：
     * 1.最大堆(大根堆)：每个子节点的值都小于或者等于它父节点。
     * 2.最小堆(小根堆)：每个子节点的值都大于或者等于它的父节点。
     * 注意：假如在一个最大堆中，最大的那一个元素总是位于index=0的位置(从树结构说就是根节点)，但是最小的元素则未必是最后一个元素。唯一能够保证的是最小的元素
     * 是一个叶节点，但是不确定是哪一个。
     *
     * 3、用处：常常用来实现优先队列，甚至讲优先队列就是堆。在java集合中，堆是通过ArrayList数组实现的。并且有一个实现类 PriorityQueue
     */



    // 堆的插入，每次总是先填满上一层，再在下一层从左往右依次插入。堆的插入步骤。
    /**
     * 思路：(最小堆)当插入一个元素时，先将这个元素插入到队列尾，然后将这个新插入的元素和它的父节点进行优先权的比较，如果比父节点的优先权要大，则和父节点
     * 呼唤位置，然后再和新的父节比较，直到比新的父节点优先权小为止。比较优先权时，最小堆与最大堆情况相反。
     */

    // 堆的删除,与插入操作相反，插入操作从下往上调整堆，而删除操作则从上往下调整堆。
    /**
     * 堆的删除操作通常都是删除优先权(值)最大的元素，也就是根节点。思路是将队列尾的元素值赋给根节点，队列尾结点赋值为null。然后跟据最大堆或最小堆定义，比较
     * 原根节点下的左右2个子节点，大(最大堆选择大的)的作为新的根节点。接着处理这个根节点左右几点，重复这个过程，直到顺序正常。
     */
}
