##### 递归:
与dfs一样

##### 回溯:
递归的一种，带有恢复状态的递归，也可以看成dfs+剪枝，本质上就是暴力穷举。  
思考3个问题：
* 路径：
* 选择列表：
* 结束条件(结束递归)：

套路(伪代码)：
```
result = []
void backtrack(路径, 选择列表):
    if 满足结束条件:
        result.add(路径)
        return

    for 选择 in 选择列表:
        做选择
        backtrack(路径, 选择列表)
        撤销选择
```

##### KMP算法: 
字符串模式匹配算法。解决的问题就是在字符串（也叫主串）中的模式（pattern）定位问题。
```
   /**
     * 朴素模式匹配算法
     *
     * 在字符匹配的过程中，不断的往回移动主串的指针来和模式串进行对比，这种行为称为回溯。
     *
     * @param s1 a,b,c,d,e,f,t,y,q,w,s,d
     * @param s2 f,t,y,q,w
     */
    private void math(String s1, String s2) {

        char[] chars1 = s1.toCharArray();
        char[] chars2 = s2.toCharArray();

        int count = chars1.length - chars2.length;//外层循环次数

        for (int i = 0; i < count; i++) {
            for (int j = 0; j < chars2.length; j++) {
                if (chars1[i + j] != chars2[j]) {  //内层依次比较主串与模版串
                    break;
                }
                //成功条件(匹配到了最后一个，没有跳出循环，说明这个是完全匹配的2个子串)
                if (j == chars2.length-1){

                }
            }
        }
    }
```

##### 前缀和

##### 深度优先搜索(DFS-Depth First Search)
就是递归啦

##### 广度优先搜索(BFS-Breadth First Search)<pT23:层序遍历二叉树>
BFS的核心思想就是把一些问题抽象成图，从一个点开始，向四周开始扩散。一般来说写BFS算法都是用「队列」这种数据结构，
每次将一个节点周围的所有节点加入队列。想到 bfs，就要联系到队列这种数据结构，想到它展开是一个图。BFS问题本质上就是一幅「图」，让你从
一个起点，走到终点，求最短路径。这就是BFS的本质，框架搞清楚直接默写。   
步骤流程：
* 1、构建队列,将初始状态(起点)放入队列：java常用的是LinkedList。(说了用到bfs就要想到队列，不管是啥，先把队列弄出来先)
* 2、构建去重(Set)集合：避免走回头路(去重)，这个根据情况看是否需要
* 3、定义操作次数计数器：其实就是一个变量值。
* 4、遍历队列：将队列内所有数据遍历，直到队列为空。其实就是取出当前队列中的每个元素并访问，这里用到poll()操作来取出元素。
* 5、更新计数器

在上面1、2、3、5、步骤可以说是固定式，能变化的只在第4步骤。对于第4步骤可以具体问题具体分析。但是一定包含以下内容在内：
* 将其他状态放入队列
* 找到目标(到达终点)

还要考虑2个问题，计数器更新，去重问题
模板代码(伪代码)
```
int BFS(Object start, Object target) {
    Queue<String> q = new LinkedList<String>(); // 构建队列
    q.offer(start); // 将初始状态加入队列
    
    Set<String> set = new HashSet<String>(); // 构建去重集合,防止重复访问
    set.add(start); // 初始状态也要放到去重集合中
    
    int step = 0; // 记录操作次数

    while (!q.isEmpty()) {
        // 访问队列内的所有元素,需要循环poll
        int size = q.size();
        for (int i = 0; i < size; i++) {
            Object o = q.poll();
            
            // 1.由此目标展开而产生的新状态，要放入到队列
            Object x = getOther(o);
                
            // 2.找到目标
            if (x == target){
            
            }
            if(!set.contains(x)){ // 标记为已访问          
                 q.offer(x);
                 set.add(x); // 也要加入到已经访问集合
            }
        }
        // 更新操作次数，有时候也可以放在开头，或者用其它形式表示
        step++;
    }
}
```

##### 排序算法(8大排序算法)

##### 二分法 (操作有序数列)
在升序数组 nums 中寻找目标值 target(注意，一定要是有序数组)，对于特定下标i，比较 [i]nums[i] 和 target 的大小：
如果[i] = nums[i]=target，则下标i 即为要寻找的下标；
如果[i] > nums[i]>target，则 target 只可能在下标i 的左侧；
如果[i] < nums[i]<target，则 target 只可能在下标i 的右侧。
基于上述事实，可以在有序数组中使用二分查找寻找目标值。   

二分查找的做法是，定义查找的范围[left,right]，初始查找范围是整个数组。每次取查找范围的中点mid，比较nums[mid] 和target 的大小，如果相等则mid 即为要
寻找的下标，如果不相等则根据nums[mid] 和 target 的大小关系将查找范围缩小一半。由于每次查找都会将查找范围缩小一半，因此二分查找的时间复杂度是 O(logn)，
其中 n 是数组的长度。二分查找的条件是查找范围不为空，即left ≤ right。如果 target 在数组中，二分查找可以保证找到 target，返回 target 在数组中的下标。
如果 target 不在数组中，则当left > right时结束查找，返回 −1。

代码模板:
```
    public int 二分查找(int[] nums, int target) {
        int low = 0, high = nums.length - 1;
        while (low <= high) {
            int mid = (high - low) / 2 + low; //这里可能会出现下标越界的情况，所以使用这种写法，与 (low+high)/2 结果是一样。
            int num = nums[mid];
            if (num == target) {
                return mid;
            } else if (num > target) {
                high = mid - 1;
            } else {
                low = mid + 1;
            }
        }
        return -1;
    }
```
此外可能还有二分的变种题型，区别就在于边界处理不同。例如可能不能取=，或者取>=,而不能是<=。或者反过来。或者边界=mid 还是=mid+1。具体问题具体分析，这点要注意。

##### 斐波那契数列思想(递归 经典问题-青蛙爬台阶)。

##### 动态规划 (DP-Dynamic Programming )
动态规划问题的一般形式就是求最值。比如说让你求最长递增子序列呀，最小距离呀等等。这也是判断能否使用动态规划解决的因素之一。求解动态规划的核心问题就是穷举。相对的
，动态规划的穷举问题一般都会存在重叠子问题、最优子结构等特征，从而能够找出转移方程。    
核心步骤：
* 定义dp数组
* 确定 base case
* 确定状态(边界条件)
* 找到转移方程
* 状态压缩(优化)

以上5个步骤其实就是动态规划解法的模板。

##### 快速幂算法: 快速算出指数非常大的幂。经典题目: 求数值x的整数n次方。

##### 乾坤大挪移(链表的删除节点操作)。

##### 快慢指针
定义一快一慢指针，快慢指针相差n个数量单位。多适用于链表或数组题目。比如求倒数第n个数(节点)，链表是否成环等等。

金典题目：  
* 剑指Offer 22、链表中倒数第k个节点

##### 分治法

##### 单调栈<p503:下一个更大的数>

##### 统计法

##### 摩尔投票法(基于某元素数量超过总数的一半。核心思想“正负抵消”)<pT29:数组中超过一半的数字>
原理分析：  
由于众数出现的次数必须超过数组长度的一半；若记众数的票数为+1 ，非众数的票数为−1，则一定有所有数字的票数和 > 0。  
核心步骤：  
* 声明2个变量：一个代表众数more，一个表示众数计数器count。
* 遍历。(默认第一个为众数more，碰到与它相同则++，不同则--。如果计数器count等于0了，表示没有众数存在，重新选取当前数为众数。重复以上步骤)
* 结果判断。(如果未声明一定存在众数，最终的结果more等于最后一个元素，这显然是错误的答案。需要统计出more的数量，判断是否大于总元素一半。)

伪代码：
```
int More(){
    int more = 0;
    int count = 0;
    for (int i : 数据集合) {
      if (count == 0) {
             more = i;
        }
        if (i == more) {
          count++;
        } else {
          count--;
        }
    }
    count = 0;
    for (int i : 数据集合) {
      if (i == more) {
          count++;
      }
    }
    return count > 数据集合.length / 2 ? more : 0;
 }
```



##### 埃氏筛(厄拉多啦筛、线性筛)<p204:计算质数>

##### 博弈类型(数学推理)<p810:黑板异或游戏>

##### 字典树 <p1707:与数组中元素的最大异或值>

##### 有效状态机(DFA) <p65:有效数字>

##### 贪心算法 <p1833:雪糕的最大数量>
贪心算法可以说是动态规划的一种特例


##### 大根堆

##### 差分数组 <p1109:航班预订统计>
概念：差分数组对应的概念是前缀和数组，对于数组[1,2,2,4]，其差分数组为[1,1,0,2]。计算方法为：差分数组的第i个数即为原数组的第i-1元素和第i个元素的差值。
同样的，已知差分数组要求原数组，计算方法就是做前缀和。差分就是是前缀和的逆向过程。题目中通常也会结合前缀和一起使用，先计算差分数组，再做前缀和求原数组。   

差分数组的性质是：  
当我们希望对原数组的某一个区间[l,r]施加一个增量inc时，差分数组d对应的改变是：d[l]增加inc，d[r+1]减少inc。这样对于区间的修改就变为了对于两个位置
的修改。并且这种修改是可以叠加的，即当我们多次对原数组的不同区间施加不同的增量，我们只要按规则修改差分数组即可。  

差分思想：  
* 开始区间累加数量。
* 结束区间+1处，要减去当前数量。因为结束区间之后的是没有当前数量的。先减去，后续做前缀和的时候，其实会互相抵消掉。


#### 未解题目()
* 131、分割回文串I
* 132、分割回文串II
* 1047、删除字符串所有相邻重复项
* 224、基本计算器
* 331、验证二叉树的前序序列化
* 115、不同的子序列
* 73、矩阵置0
* 456、132模式
* 61、旋转链表
* 173、二叉树迭代器
* 190、颠倒二进制位
* 90、子集II
* 783、二叉搜索树节点最小距离
* 208、实现Trie(前缀树)
* 213、打家劫舍II
* 87、扰乱字符串
* 220、存在重复元素III
* 26、删除有序数组中的重复项
* 403、青蛙过河
* 1035、不相交的线
* 1707、与数组中元素的最大异或值
* 664、奇怪的打印机
* 1787、使所有区间的异或结果为零
* 1744、你能在你最喜欢的那天吃到你最喜欢的糖果吗
* 483、最小好进制
* 815、公交路线
* 1711、大餐计数
* 930、和相同的二元子数组
* 1818、绝对差值和
* 743、网络延迟时间
* 847、访问所有节点的最短路径 (图)
* 457、环形数组是否存在循环
* 313、超级丑数
* 413、等差数列划分
* 446、等差数列划分II(子序列)
* 516、最长回文子序列
* 233、数字 1 的个数
* 1583、统计不开心的朋友
* 576、出界的路径数
* 526、优美的排列
* 551、学生出勤记录I
* 552、学生出勤记录II
* 345、反转字符串中的元音字母
* 541、反转字符串 II
* 443、压缩字符串
* 789、逃脱阻碍者
* 1646、获取生成数组中的最大值
* 787、K 站中转内最便宜的航班
* 797、所有可能的路径
* 881、救生艇
* 295、数据流的中位数


