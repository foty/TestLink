package com.example.testlink.calculate.sword_for_offer;

/**
 * Create by lxx
 * Date : 2020/7/20 16:10
 * Use by 从1到非负整数n中1出现的次数。
 */
public class T32 {

    public static void main(String[] args) {
        System.out.println("count=  " + solve(1410065408)); // 1737167499
    }


    /**
     * 使用高低位法(找规律)，即分别统计每一位置(个位，十位，百位...)出现1的次数，最后将他们相加。
     * 现定义如下：
     * n = 当前选择的位置(计数单位)。
     * h = 表示高位
     * l = 表示地位。
     * 举个例子： 12345. 假如
     * n = 3，就是数字3所在的位置(百位)，
     * 高位h = 12所在的位置(万位，千位)
     * 低位l = 45所在的位置(十位，个位)
     * <p>
     * 对于每个位置都会出现小于1(等于0)，等于1，大于1的这三种情况。
     * 举例：31068。
     * <p>
     * 1. n = 0(n<1)：
     * 在第3位，即百位上的数字是0。那么在百位能出现1的数字有:
     * [00100~00199,01100~01199,02100~02199,...,30100~30199]。
     * 每个区间有100个数(第一个数也要算上的)，一共就是 [100 * 31] 个。
     * <p>
     * 2. n = 1:
     * n = 1在千位位置，那么在千位能出现的1的数字有：
     * [01000~01999,11000~11999,21000~21999,31000~31068]
     * 每个区间以1000为计数单位(同样第一个数也要算上)，一共就是 [1000 * 3 + (68 + 1)(31000~31068是69个数)]
     * <p>
     * 3. n > 1:
     * n>1,拿数字6作为分析，就是在十位上能出现1数字的有：
     * [00010~00019,00110~00119,00210~00219,...,30910~30919,31010~31019]
     * m每个区间以10 最为计数单位，一共就是 [10 *(310 +1)(从000到310是311个数)]
     * 最后将所有位数上能出现1的次数相加起来就是这个题目的解。
     *
     * 注意的是 n是int取值范围，无限次乘以10会超过这个范围导致结果计算错误，再统计高低位时需要注意。
     *
     * @param n
     * @return
     */
    public static int solve(int n) { // 1<n<2^31  2147483648
        int count = 0;
        int rate = 1;//计数单位。

        int cur = n % 10;
        int h = n / 10;
        int l = 0;

        while (true) {
            if (h == 0 && cur == 0) break;

            if (cur == 0) {
                count += h * rate;
            } else if (cur == 1) {
                count += h * rate + l + 1;
            } else {
                count += rate * (h + 1);
            }

            l = cur * rate + l; //低位
            cur = h % 10;   //当前位
            h = h / 10;  // 高位

            rate *= 10;
        }
        return count;
    }
}
