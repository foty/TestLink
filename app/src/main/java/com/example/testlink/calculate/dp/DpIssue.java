package com.example.testlink.calculate.dp;

/**
 * Create by lxx
 * Date : 2021/4/25 10:43
 * Use by dp金典问题
 */
public class DpIssue {

    public static void main(String[] args) {
        int[] ints = new int[]{-2, 1, -3, 4, -1, 2, 1, -5, 4};
        p53(ints);
    }


    /**
     * 最大子序和
     */
    public static int p53(int[] nums) {
        /**
         * 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
         * 示例 1：
         *
         * 输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
         * 输出：6
         * 解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
         */

        /**
         * dp思路：
         *
         * 1、定义dp数组：
         * 要找到最大和的连续子数组，可以分解成多个子问题。在数组nums中，某元素下标为i，如果知道了前i-1个子数组的最大和，
         * 那么前i个子数组的最大和 = sum(i-1) + nums[i]。注意这里的最大和sum(i)是对应前i个数的最大和，也就是数sum(i)
         * 不一定是最终答案，因为有可能sum(i-1) > sum(i)。
         * dp[i] 表示前i个数的最大子序和。
         *
         * 2、确定base case：
         * base case为第一个元素。dp[0] = nums[0]
         *
         * 3、边界条件
         * 数组nums的长度
         *
         * 4、转移方程
         * 很明显，dp[i] = max(dp[i-1]+ nums[i],nums[i])。为什么是在2个数中选择最大的呢？因为每个元素也
         * 能单独成为子数组，如果dp[i-1]加上nums[i]反而比自身小了，那么完全可以脱离dp[i-1],自己独立一个子序列
         * 出来。可能会有疑问，为什么不再跟dp[i-1]比较，如果dp[i-1]比上面2个数都大的话，不用dp[i-1]。这里要注意
         * 这个dp[i]针对的是前i个数，那么它的子序和只能是前i个数加上第i数的和，或者i独立一个作为子序和。如果使用
         * dp[i-1]的话就更像是直接求出最终答案，而dp[i]却不是最终答案。最终答案还需要通过比较取出最大的那个数(一开
         * 始我也进入这个误区，实际就是对dp数组的定义不够明确)。
         *
         * 5、状态压缩
         * 所有涉及只与dp[i]、dp[i-1]相关，可以使用2个变量保存，替换dp数组，空间由O(n):数组大小为n -> O(1)。
         */

        // 标准dp(未优化空间)

        int[] dp = new int[nums.length];
        dp[0] = nums[0]; // 题目声明 nums.length >= 1
        int max = dp[0];
        for (int i = 1; i < nums.length; i++) {
            dp[i] = Math.max(dp[i - 1] + nums[i], nums[i]);
            max = Math.max(max, dp[i]);
        }

        // 优化空间
        int pre, aft;
        pre = nums[0];
        for (int i = 1; i < nums.length; i++) {
            aft = Math.max(pre + nums[i], nums[i]);
            pre = aft;
            max = Math.max(max, aft);
        }
//        执行用时：1 ms, 在所有 Java 提交中击败了 94.84% 的用户
//        内存消耗：38.5 MB, 在所有 Java 提交中击败了 41.95% 的用户
        return max;
    }

    /**
     * 爬楼梯
     */
    public int p70(int n) {
        /**
         * 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。
         * 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？
         * 注意：给定 n 是一个正整数。
         *
         * 示例 1：
         *
         * 输入： 2
         * 输出： 2
         * 解释： 有两种方法可以爬到楼顶。
         * 1.  1 阶 + 1 阶
         * 2.  2 阶
         */

        /**
         * 思路：
         * 1、定义dp数组：
         * 设dp[i]表示爬i级楼梯的方法总数。
         *
         * 2、确定base case：
         * 有题目可以知道
         * dp[0] = 1,dp[1]= 1。注意为什么dp[0]是等于1而不是等于0。因为从0阶台阶爬到0阶台阶也可以当成是一种方案。
         *
         * 3、边界条件
         * n的大小
         *
         * 4、转移方程
         * 两种情况：
         * 当最后一步爬1阶楼梯时，有dp[i] = dp[i-1];
         * 当最后一步爬2阶楼梯时，有dp[i] = dp[i-2];
         * 最后结果当然是2中情况相加
         *
         * 5、状态压缩
         * 从始到终只与dp[i]，dp[i-1]，dp[i-2]相关，可以使用3个变量代替dp[]数组，从空间O(n)：数组大小为n ->O(1)。
         */

        int[] dp = new int[n + 1];
        dp[0] = 1;
        dp[1] = 1;
        for (int i = 2; i < n; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
//        return dp[n];

        int step1 = 1, step2 = 1, step = 0;
        for (int i = 2; i <= n; i++) {
            step = step1 + step2;
            step1 = step2;
            step2 = step;
        }
        return step;

//        执行用时：0 ms, 在所有 Java 提交中击败了 100.00% 的用户
//        内存消耗：35.1 MB, 在所有 Java 提交中击败了 70.67% 的用户
    }

    /**
     * 买卖股票的最佳时机  121
     */
    public int maxProfit(int[] prices) {
        /**
         * 给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。
         * 你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。
         * 返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。
         *
         * 示例 1：
         * 输入：[7,1,5,3,6,4]
         * 输出：5
         * 解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
         * 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
         *
         *  提示：
         * 1 <= prices.length <= 105
         * 0 <= prices[i] <= 104
         */

        /**
         * 思路
         * 1、定义dp数组
         * 要求是获取最大利润，那么肯定就是最低点买入，最高点卖出。前提条件之一：卖出不能在买入之前。我的理解是规定了一种减法顺序，只能是用后面元素减前面的元素。
         * 设dp[i]表示在第i天卖出时的利润。那么在知道第i-1天卖出的利润后，第i天的利润等于第i-1天卖出的利润加上第i-1天买入第i天卖出的利润。注意第i-1天买入第i
         * 天卖出产生的利润有可能是负数，也就是亏本。但是对于求dp[i]来说是合理的。(ps说点废话:对于dp[i]更加直接的求法是price[i] - price[min],min为买入点,
         * 但是如果这样写也实在是没有必要写dp了，hhh)。所以转移方程为：
         * dp[i] = dp[i-1] + price[i] - price[i-1]。
         * 前面一切基于确定了最低点的情况下。但是实际上最低点也是在变化的。可以使用一个变量min表示dp[i]的最低点，当碰到比min还低时，重新计算最低点，此时当天的
         * 利润也就等于0了。最后从dp数组中取出最大的元素即为题目的最大利润(注意不是dp[price.length])。
         *
         * 2、明确base case
         * dp[0] = 0，今天买入今天卖出或者只买入不卖出，当天的利润都是0
         *
         * 3、边界条件
         * 使用一个变量min表示dp[i]的最低点，当碰到比min还低时，重新计算最低点，此时当天的利润也就等于0了。最后从dp数组中取出最大的元素即为题目的最大利
         * 润(注意不是dp[price.length])
         *
         * 4、转移方程
         * 当前比买入点要高时：dp[i] = dp[i-1] + price[i] - price[i-1]。
         *
         * 5、状态压缩
         * 将空间复杂度从O(n)优化到O(1),n为数组长度。
         */
        int min = 0;
        int max = 0;
        int[] dp = new int[prices.length];
        dp[0] = 0;
        for (int i = 1; i < prices.length; i++) {
            if (prices[i] < prices[min]) {
                dp[i] = 0; //今天买入
                min = i;
                continue;
            }
            dp[i] = dp[i - 1] + prices[i] - prices[i - 1];
            max = Math.max(max, dp[i]);
        }
        return max;
//        执行用时：4 ms, 在所有 Java 提交中击败了 27.39% 的用户
//        内存消耗：54.1 MB, 在所有 Java 提交中击败了 17.64% 的用户
    }

    /**
     * 01背包问题
     */
    public int maxValue(int N, int V, int[] v, int[] w) {
        /**
         * 有N件物品和一个容量是V的背包。每件物品有且只有一件。
         * 第i件物品的体积是v[i]，价值是w[i]。
         *
         * 求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。
         *
         * 示例 1：
         * 输入: N = 3, V = 4, v = [4,2,3], w = [4,2,3]
         * 输出: 4
         * 解释: 只选第一件物品，可使价值最大。
         *
         * 示例 2：
         * 输入: N = 3, V = 5, v = [4,2,3], w = [4,2,3]
         * 输出: 5
         * 解释: 不选第一件物品，选择第二件和第三件物品，可使价值最大。
         */

        /**
         * 思路dp
         *
         * 1、定义dp数组：
         * 对于4个入参：N是物品数量，V是背包容量，v是每个物品重量，w是每件物品价值。v跟w属于固定参数不用考虑。那么只考虑N跟V。
         * 根据N,V抽象出dp数组的含义：dp[i][j] = 当拿到第i件物品，剩余容量为j时，此时背包中物品的价值。问题最终结果为dp[i][j]。
         *
         * 2、明确base case：
         * base case就是只拿v中的第一件物品的情况。
         *
         * 3、寻找状态转移方程
         * 对于第j物品，只有拿与不拿2种情况。不拿，则dp[i][j]等于前一个物品，容量不变的价值。即：dp[i-1][j];拿，当前价值等于于
         * 前i-1个物品，但重量为剩余容量[j - v[i]]的价值加上当前物品的价值w[j]。即dp[i-1][V-v[i]] + w[j]
         *
         * 4、边界条件
         * 拿与不拿有条件限制，就是物品容量不能超过背包总容量。
         *
         * 5、状态压缩
         */

        // 背包容量是可以等于V的，对于数组从0开始需要+1;
        int[][] dp = new int[N][V + 1];
        // 处理base case。
        for (int i = 0; i <= V; i++) {
            dp[0][i] = i >= v[i] ? w[0] : 0;
        }
        for (int i = 1; i < N; i++) {
            for (int j = 0; j <= V; j++) {
                //不拿：容量没变，价值等于前一个物品价值。
                int x = dp[i - 1][j];
                //拿：
                int y = 0;
                if (j >= v[i])
                    y = dp[i - 1][j - v[i]] + w[i];

                dp[i][j] = Math.max(x, y);
            }
        }
        return dp[N-1][V]; // 待验证
    }
}
